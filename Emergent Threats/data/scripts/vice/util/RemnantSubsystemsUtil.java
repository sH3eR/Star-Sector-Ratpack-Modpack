package data.scripts.vice.util;

import java.util.ArrayList;
import java.util.List;

import com.fs.starfarer.api.Global;
import com.fs.starfarer.api.combat.MutableShipStatsAPI;
import com.fs.starfarer.api.combat.ShipAPI;
import com.fs.starfarer.api.combat.ShipVariantAPI;
import com.fs.starfarer.api.combat.ShipHullSpecAPI;
import com.fs.starfarer.api.fleet.FleetMemberAPI;

public class RemnantSubsystemsUtil {

	//data
	private static String HANGAR_MOD_OVERLAP = "Incompatible hangar modification present";
	private static String HUB = "Subsystem is activated on ship central hub";
	private static String MANUFACTURER = "Incompatible hull. AI Subsystem Integration or comparable upgrade required";
	private static String MODCOUNT = "Adaptive subsystem limited to one per ship";
	private static String MODULE = "Cannot be installed on ship modules";
	private static String NOSHIELDS = "Ship has no shields";
	private static String UNNECESSARY = "Ship can already equip adaptive subsystems";
	private static String SIERRA_MOD_OVERLAP = "Unhandled Exception: \"Phase Concord\" is not an instance of Tri-Tachyon approved phase field protocol";
	
	private static String MODULE_HANDLER = "vice_module_handler";
	
	//for letting ships use adaptive subsystems when these hullmods are equipped
	private static String ADAPTIVE_ENABLING_HULLMOD = "vice_ai_subsystem_integration";
	private static String ABOMINATION_INTERFACE_HULLMOD = "vice_abomination_interface";
	private static String SHIPWIDE_INTEGRATION_HULLMOD = "vice_shipwide_integration";
	private static String ADAPTIVE_TACTICAL_CORE = "vice_adaptive_tactical_core";
	
	//skeleton crew upper limit for ADAPTIVE_ENABLING_HULLMOD, need ABOMINATION_INTERFACE_HULLMOD if exceeded
	private static float AUTOMATION_MIN_CREW_UPPER_LIMIT = 1500f;
	
	//ships made by manufacturer can use adaptive subsystem hullmods
	private static List<String> MANUFACTURER_LIST = new ArrayList<String>();
	static {
		MANUFACTURER_LIST.add("Remnant");
		MANUFACTURER_LIST.add("Anomalous Phase-Tech");
		MANUFACTURER_LIST.add("Dustkeeper Proxies");
		MANUFACTURER_LIST.add("Dustkeeper Contingency");
		MANUFACTURER_LIST.add("Remnant Mess Object");
		MANUFACTURER_LIST.add("Research Mandate");
		MANUFACTURER_LIST.add("[database_error]");
		MANUFACTURER_LIST.add("XIV Remnant");
		MANUFACTURER_LIST.add("Remnant Defector");
		MANUFACTURER_LIST.add("Volantian Remnant Conversion");
	}
	
	//make ships qualify for adaptive subsystems despite not having the correct manufacturer. Takes highest priority.
	//need to add ***_default_D ship to make d-modded version generated by game valid as well
	private static List<String> QUALIFIED_SHIPLIST = new ArrayList<String>();
	static {
		QUALIFIED_SHIPLIST.add("vice_mimesis_p");
		QUALIFIED_SHIPLIST.add("vice_mimesis_p_default_D");
		QUALIFIED_SHIPLIST.add("vice_praxis");
		QUALIFIED_SHIPLIST.add("vice_praxis_default_D");
		QUALIFIED_SHIPLIST.add("hmi_limina");
		QUALIFIED_SHIPLIST.add("hmi_limina_default_D");
		QUALIFIED_SHIPLIST.add("candor_ix");
		QUALIFIED_SHIPLIST.add("candor_ix_default_D");
		QUALIFIED_SHIPLIST.add("radiant_ix");
		QUALIFIED_SHIPLIST.add("radiant_ix_default_D");
		QUALIFIED_SHIPLIST.add("radiant_tw");
		QUALIFIED_SHIPLIST.add("radiant_tw_default_D");
		QUALIFIED_SHIPLIST.add("radiant_ix_hvb");
		QUALIFIED_SHIPLIST.add("radiant_ix_hvb_default_D");
		QUALIFIED_SHIPLIST.add("tahlan_Nameless");
		QUALIFIED_SHIPLIST.add("tahlan_Nameless_default_D");
		QUALIFIED_SHIPLIST.add("tahlan_Timeless");
		QUALIFIED_SHIPLIST.add("tahlan_Timeless_default_D");
		QUALIFIED_SHIPLIST.add("tahlan_Timeless_retro");
		QUALIFIED_SHIPLIST.add("tahlan_Timeless_retro_default_D");
	}

	//bans specific ships from adaptive subsystems unless they have ABOMINATION_INTERFACE_HULLMOD. 
	//supercedes MANUFACTURER_LIST so specific ships from qualified manufacturer can be exempt
	private static List<String> BANNED_SHIPLIST = new ArrayList<String>();
	static {
		BANNED_SHIPLIST.add("guardian");
		BANNED_SHIPLIST.add("guardian_default_D");
		BANNED_SHIPLIST.add("zea_boss_ninaya");
		BANNED_SHIPLIST.add("zea_boss_ninaya_default_D");
		BANNED_SHIPLIST.add("zea_boss_ninmah");
		BANNED_SHIPLIST.add("zea_boss_ninmah_default_D");
		BANNED_SHIPLIST.add("zea_boss_nineveh");
		BANNED_SHIPLIST.add("zea_boss_nineveh_default_D");
	}

	//ships made by manufacturer representing end game mod factions that don't need the extra help
	//players can still force compatibility with ABOMINATION_INTERFACE_HULLMOD for captured ships
	private static List<String> ABOMINATION_LIST = new ArrayList<String>();
	static {
		ABOMINATION_LIST.add("Unknown"); //Omega
		ABOMINATION_LIST.add("IV Battlegroup");
		ABOMINATION_LIST.add("VI Battlegroup");
		ABOMINATION_LIST.add("IX Battlegroup");
		ABOMINATION_LIST.add("XIII Battlegroup");
		ABOMINATION_LIST.add("XIV Battlegroup"); //Safeguard
		ABOMINATION_LIST.add("Shackles Garrison"); //XXVII Battlegroup
		ABOMINATION_LIST.add("Legio Infernalis");
		ABOMINATION_LIST.add("Nightwatch");
		ABOMINATION_LIST.add("The Great Houses");
		ABOMINATION_LIST.add("Rosenritter");
		ABOMINATION_LIST.add("Blade Breakers");
		ABOMINATION_LIST.add("Breaker Prototype");
		ABOMINATION_LIST.add("Bio Tech");
		ABOMINATION_LIST.add("Exotic Tech");
		ABOMINATION_LIST.add("Plague-bearer Tech");
		ABOMINATION_LIST.add("Abyssal");
		ABOMINATION_LIST.add("Seraph");
		ABOMINATION_LIST.add("Exo-Tech");
		ABOMINATION_LIST.add("Void");
		ABOMINATION_LIST.add("Unknown Prototype");
		ABOMINATION_LIST.add("Project Enigma");
		ABOMINATION_LIST.add("Elysia");
		ABOMINATION_LIST.add("Dusk");
		ABOMINATION_LIST.add("Dawntide");
		//includes IBB "Unique" ships in isAbomination method
	}

	//phase hullmods that prohibit Adaptive Phase Coils
	private static List<String> SIERRA_MODLIST = new ArrayList<String>();
	static {
		SIERRA_MODLIST.add("sotf_serenity");
		SIERRA_MODLIST.add("sotf_fervor");
		SIERRA_MODLIST.add("sotf_wispersong");
	}
	
	//methods
	public float getAutomationCrewLimit() {
		return AUTOMATION_MIN_CREW_UPPER_LIMIT;
	}
	
	public boolean isMinCrewWithinAutomationLimit(ShipAPI ship){
		return isMinCrewWithinAutomationLimit(ship.getVariant());
	}
	
	public boolean isMinCrewWithinAutomationLimit(ShipVariantAPI variant) {
		return (variant.getHullSpec().getMinCrew() <= AUTOMATION_MIN_CREW_UPPER_LIMIT);
	}
	
	//master method used by all adaptive hullmods to check for compatibility, see isApplicableWithoutSynthesis
	public boolean isApplicable(ShipAPI ship) {
		//always valid for NPC Synthesis fleets
		if (ship.getFleetMember() == null 
				|| ship.getFleetMember().getFleetData() == null 
				|| ship.getFleetMember().getFleetData().getFleet() == null 
				|| !ship.getFleetMember().getFleetData().getFleet().isPlayerFleet()) return true;
		return isApplicable(ship.getVariant());
	}
	
	public boolean isApplicable(ShipVariantAPI variant) {
		if (Global.getSector().getMemoryWithoutUpdate().is("$xo_synthesis_is_active", true)) return true;
		return isApplicableWithoutSynthesis(variant);
	}
	
	//for synthesis aptitude skill to check if ship can already use subsystems and should therefore gain CR
	public boolean isApplicableWithoutSynthesis(ShipVariantAPI variant) {
		if (variant.hasHullMod(SHIPWIDE_INTEGRATION_HULLMOD)) return true;
		if (variant.hasHullMod(ABOMINATION_INTERFACE_HULLMOD)) return true;
		for (String mod : variant.getSMods()) {
			if (mod.equals(ADAPTIVE_ENABLING_HULLMOD)) return true;
		}
		if (isExperimental(variant)) return true; //Experimental Hullmods compatibility workaround
		else if (isAbomination(variant)) return false;
		if (isApplicableHull(variant)) return true;
		if (variant.getHullSpec().isBuiltInMod(ADAPTIVE_ENABLING_HULLMOD)) return true;
		return false;
	}
	
	//Experimental Hullmods compatibility workaround
	public boolean isExperimental(ShipAPI ship) {
		return isExperimental(ship.getVariant());
	}
	
	public boolean isExperimental(ShipVariantAPI variant) {
		if (variant.hasHullMod("rat_abyssal_grid") && !variant.hasHullMod(ABOMINATION_INTERFACE_HULLMOD)) return false;
		return (variant.getHullSpec().getManufacturer().equals("Experimental")
					&& variant.hasHullMod("ehm_base")
					&& (variant.hasHullMod("automated") || variant.hasHullMod("ehm_mr_aiswitch")));
	}
	
	//is AI Subsystem Integration needed, no for hulls that can already take subsystems or are forbidden from them
	public boolean isSubsystemIntegrationApplicable(ShipAPI ship) {
		if (isAbomination(ship)) return false;
		if (isApplicableHull(ship)) return false;
		return true;
	}
	
	//is ship a banned type or requires too much min crew and is in need of ABOMINATION_INTERFACE_HULLMOD to take adaptive subsystems
	public boolean isAbomination(ShipAPI ship) {
		return isAbomination(ship.getVariant());
	}
	
	public boolean isAbomination(ShipVariantAPI variant) {
		String hullId = variant.getHullSpec().getHullId();
		for (String s : QUALIFIED_SHIPLIST) {
			if (hullId.equals(s)) return false;
		}
		if (!isMinCrewWithinAutomationLimit(variant)) return true;
		String manufacturer = variant.getHullSpec().getManufacturer();
		for (String s : ABOMINATION_LIST) {
			if (manufacturer.equals(s)) return true;
			else if (manufacturer.startsWith("Unique")) return true; //IBB Bounties
		}
		for (String s : BANNED_SHIPLIST) {
			if (hullId.equals(s)) return true;
		}
		return false;
	}
	
	//is ship the right manufacturer or on an exemption list making it always qualify
	private boolean isApplicableHull(ShipAPI ship) {
		return isApplicableHull(ship.getVariant());
	}
	
	private boolean isApplicableHull(ShipVariantAPI variant) {
		String manufacturer = variant.getHullSpec().getManufacturer();
		String hullId = variant.getHullSpec().getHullId();
		for (String s : MANUFACTURER_LIST) {
			if (manufacturer.equals(s)) return true;
		}
		for (String s : QUALIFIED_SHIPLIST) {
			if (hullId.equals(s)) return true;
		}
		return false;
	}
	
	//does ship have SotF hullmods. Used by phase related mods to check for compatibility
	public boolean hasSierraMods(ShipAPI ship) {
		for (String s : SIERRA_MODLIST) {
			if (ship.getVariant().hasHullMod(s)) return true;
		}
		return false;
	}
	
	//limit one adaptive mod at a time. Not enabled at RModCount <= 1, leave at 1 for easier switching
	public boolean isOnlyRemnantMod(ShipAPI ship) {
		int RModCount = 0;
		for (String str : ship.getVariant().getHullMods()) {
			if (str.startsWith("vice_adaptive")) RModCount++;
		}
		return RModCount <= 1;
	}

	//workaround for various module checking methods not always working
	public boolean isModuleCheck(ShipAPI ship) {
		if (ship.isStationModule() || ship.getParentStation() != null) return true;
		ShipHullSpecAPI spec = ship.getVariant().getHullSpec();
		if (spec.getSuppliesPerMonth() == 0 && spec.getEngineSpec().getMaxSpeed() == 0) return true;
		return false;
	}
	
	public boolean isModuleCheck(MutableShipStatsAPI stats) {
		ShipHullSpecAPI spec = stats.getVariant().getHullSpec();
		if (spec.getSuppliesPerMonth() == 0 && spec.getEngineSpec().getMaxSpeed() == 0) return true;
		return false;
	}
	
	//applies Shipwide Integration to all submodules
	public void applyShipwideIntegration(ShipVariantAPI variant) {
		if (variant.getModuleSlots() == null) return;
		List<String> slots = variant.getModuleSlots();
		for (String slot : slots) {
			if (variant.getModuleVariant(slot) == null) continue;
			variant.getModuleVariant(slot).addPermaMod(SHIPWIDE_INTEGRATION_HULLMOD);
		}
	}

	public void applyShipwideHullMod(ShipVariantAPI variant, String hullmod, boolean isPermaMod) {
		if (variant.getModuleSlots() == null) return;
		List<String> slots = variant.getModuleSlots();
		for (String slot : slots) {
			if (variant.getModuleVariant(slot) == null) continue;
			if (isPermaMod) variant.getModuleVariant(slot).addPermaMod(hullmod);
			if (!isPermaMod) variant.getModuleVariant(slot).addMod(hullmod);
		}
	}
	
	public void removeShipwideHullMod(ShipVariantAPI variant, String hullmod) {
		if (variant.getModuleSlots() == null) return;
		List<String> slots = variant.getModuleSlots();
		for (String slot : slots) {
			if (variant.getModuleVariant(slot) == null) continue;
			variant.getModuleVariant(slot).getPermaMods().remove(hullmod);
			variant.getModuleVariant(slot).getHullMods().remove(hullmod);
		}
	}
	
	public void addModuleHandler(MutableShipStatsAPI stats) {
		ShipVariantAPI variant = stats.getVariant();
		variant.addPermaMod(MODULE_HANDLER);	
		//needed to clear handler due to module linker
		removeShipwideHullMod(variant, MODULE_HANDLER);
	}
	
	public boolean isWithoutCaptain(MutableShipStatsAPI stats, boolean isSynthesisExempt) {
		if (!isSynthesisExempt) return isWithoutCaptain(stats);
		boolean isSynthesisCore = false;
		if (stats.getEntity() instanceof ShipAPI) {
			ShipAPI ship = (ShipAPI) stats.getEntity();
			if (ship.getCaptain() != null && ship.getCaptain().getAICoreId() != null ) {
				if (ship.getCaptain().getAICoreId().equals("xo_synthesis_core")) isSynthesisCore = true;
			}
		}
		return (isSynthesisCore || isWithoutCaptain(stats));
	}
	
	public boolean isWithoutCaptain(MutableShipStatsAPI stats) {
		if (stats.getEntity() == null || stats.getFleetMember() == null) return true;
		if (stats.getEntity() instanceof ShipAPI) {
			ShipAPI ship = (ShipAPI) stats.getEntity();
			if (ship.getCaptain() == null) return true;
			return ship.getCaptain().isDefault();
		} 
		else {
			FleetMemberAPI member = stats.getFleetMember();
			if (member.getCaptain() == null) return true;
			return member.getCaptain().isDefault();
		}
	}
	
	public String getIncompatibleCauseString(String cause) {
		if (cause.equals("hangarmodoverlap")) return HANGAR_MOD_OVERLAP;
		if (cause.equals("hub")) return HUB;
		if (cause.equals("manufacturer")) return MANUFACTURER;
		if (cause.equals("modcount")) return MODCOUNT;
		if (cause.equals("module")) return MODULE;
		if (cause.equals("noshields")) return NOSHIELDS;
		if (cause.equals("unnecessary")) return UNNECESSARY;
		if (cause.equals("sierra")) return SIERRA_MOD_OVERLAP;
		
		return null;
	}
}
